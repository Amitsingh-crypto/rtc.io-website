<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="X-UA-Compatible" content="chrome=1" />
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<meta name="format-detection" content="telephone=no" />
<meta name="viewport" content="user-scalable=no, initial-scale=1, maximum-scale=1, minimum-scale=1, width=device-width" />
<title>rtc.io</title>
<link rel="stylesheet" type="text/css" href="css/reset.css" />
<link rel="stylesheet" type="text/css" href="css/main.css" />
<!-- responsive -->
<link rel="stylesheet" media="screen and (max-width: 960px)" href="css/tablet.css" />
<link rel="stylesheet" media="screen and (max-width: 710px)" href="css/phone.css" />
<link rel="stylesheet" type="text/css" href="fonts/source-sans/stylesheet.css" />
<link rel="stylesheet" type="text/css" href="css/code.css" />
</head>
<body>

<a class="scroll-point pt-top" name="top"></a>
<header>
<a href="https://github.com/rtc-io"><img class="fork" src="https://s3.amazonaws.com/github/ribbons/forkme_right_orange_ff7600.png" alt="Fork me on GitHub" /></a>
<a class="scroll-point pt-top" name="top"></a>
<div class="site">
  <div class="logo" data-subtext="OpenSource WebRTC">
    <a href="index.html">rtc.io</a>
  </div>
  <nav>
    <ul>
    <li><a href="index.html">About</a></li>
    <li><a href="tutorials.html">Tutorials</a></li>
    <li><a href="demos.html">Demos</a></li>
    <li><a href="modules.html">Modules</a></li>
    </ul>
  </nav>
</div>
<div class="shadow"></div>
</header>
<div class="main" role="content"><h1 id="rtc-signaller">rtc-signaller</h1>
<p>The <code>rtc-signaller</code> module provides a transportless signalling
mechanism for WebRTC.</p>
<p><a href="https://nodei.co/npm/rtc-signaller/"><img src="https://nodei.co/npm/rtc-signaller.png" alt="NPM" /></a></p>
<p><a href="https://travis-ci.org/rtc-io/rtc-signaller"><img src="https://travis-ci.org/rtc-io/rtc-signaller.png?branch=master" alt="Build Status" /></a>
<a href="http://github.com/hughsk/stability-badges"><img src="http://hughsk.github.io/stability-badges/dist/unstable.svg" alt="unstable" /></a></p>
<h2 id="purpose">Purpose</h2>
<p>The signaller provides set of client-side tools that assist with the
setting up an <code>PeerConnection</code> and helping them communicate. All that is
required for the signaller to operate is a suitable messenger.</p>
<p>A messenger is a simple object that implements node
<a href="http://nodejs.org/api/events.html">EventEmitter</a> style <code>on</code> events for
<code>open</code>, <code>close</code>, <code>message</code> events, and also a <code>send</code> method by which
data will be send &quot;over-the-wire&quot;.</p>
<p>By using this approach, we can conduct signalling over any number of
mechanisms:</p>
<ul>
<li>local, in memory message passing</li>
<li>via WebSockets and higher level abstractions (such as
<a href="https://github.com/primus/primus">primus</a>)</li>
<li>also over WebRTC data-channels (very meta, and admittedly a little
complicated).</li>
</ul>
<h2 id="getting-started">Getting Started</h2>
<p>To work with the signaller, you first need a messenger of some kind. If you
have run up a version of the
<a href="https://github.com/rtc-io/rtc-switchboard">rtc-switchboard</a> somewhere then
the following example should work:</p>
<div class="highlight"><pre><span class="c1">// to be completed</span>
</pre></div>

<p>While the example above demonstrates communication between two endpoints
via websockets, it does not go into detail on setting up a WebRTC peer
connection (as that is significantly more involved).  If you are looking for
an easy way to do this, I&#39;d recommend checking out
<a href="https://github.com/rtc-io/rtc-quickconnect">rtc-quickconnect</a> or
<a href="https://github.com/rtc-io/rtc-glue">rtc-glue</a>.</p>
<h2 id="signal-flow-diagrams">Signal Flow Diagrams</h2>
<p>Displayed below are some diagrams how the signalling flow between peers
behaves.  In each of the diagrams we illustrate three peers (A, B and C)
participating discovery and coordinating RTCPeerConnection handshakes.</p>
<p>In each case, only the interaction between the clients is represented not
how a signalling server
(such as <a href="https://github.com/rtc-io/rtc-switchboard">rtc-switchboard</a>) would
pass on broadcast messages, etc.  This is done for two reasons:</p>
<ol>
<li>It is out of scope of this documentation.</li>
<li>The <code>rtc-signaller</code> has been designed to work without having to rely on
any intelligence in the server side signalling component.  In the
instance that a signaller broadcasts all messages to all connected peers
then <code>rtc-signaller</code> should be smart enough to make sure everything works
as expected.</li>
</ol>
<h3 id="peer-discovery-announcement">Peer Discovery / Announcement</h3>
<p>This diagram illustrates the process of how peer <code>A</code> announces itself to
peers <code>B</code> and <code>C</code>, and in turn they announce themselves.</p>
<p><img src="https://raw.github.com/rtc-io/rtc-signaller/master/docs/announce.png" alt="" /></p>
<h3 id="editing-updating-the-diagrams">Editing / Updating the Diagrams</h3>
<p>Each of the diagrams has been generated using
<a href="http://www.mcternan.me.uk/mscgen/index.html">mscgen</a> and the source for
these documents can be found in the <code>docs/</code> folder of this repository.</p>
<h2 id="reference">Reference</h2>
<p>The <code>rtc-signaller</code> module is designed to be used primarily in a functional
way and when called it creates a new signaller that will enable
you to communicate with other peers via your messaging network.</p>
<div class="highlight"><pre><span class="c1">// create a signaller from something that knows how to send messages</span>
<span class="kd">var</span> <span class="nx">signaller</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;rtc-signaller&#39;</span><span class="p">)(</span><span class="nx">messenger</span><span class="p">);</span>
</pre></div>

<h3 id="signaller-send-data-">signaller#send(data)</h3>
<p>Send data over the messenging interface.</p>
<h3 id="signaller-announce-data-">signaller#announce(data?)</h3>
<p>The <code>announce</code> function of the signaller will pass an <code>/announce</code> message
through the messenger network.  When no additional data is supplied to
this function then only the id of the signaller is sent to all active
members of the messenging network.</p>
<p>As a unique it is generally insufficient information to determine whether
a peer is a good match for another (for instance,  you might be looking
for other parties by name or role) it is generally a good idea to provide
some additional information during this announce call:</p>
<div class="highlight"><pre><span class="nx">signaller</span><span class="p">.</span><span class="nx">announce</span><span class="p">({</span> <span class="nx">role</span><span class="o">:</span> <span class="s1">&#39;translator&#39;</span> <span class="p">});</span>
</pre></div>

<p><strong>NOTE:</strong> In some particular messenger types may attach or infer
additional data during the announce phase.  For instance, socket.io
connections are generally organised into rooms which is inferred
information that limits the messaging scope.</p>
<h3 id="signaller-leave-">signaller#leave()</h3>
<p>Leave the messenger mesh</p>
<h3 id="signaller-lock-targetid-opts-callback-">signaller#lock(targetId, opts?, callback?)</h3>
<p>Attempt to get a temporary exclusive lock on the communication
channel between the local signaller and the specified target peer id.</p>
<h3 id="signaller-to-targetid-">signaller#to(targetId)</h3>
<p>The to method returns an encapsulated</p>
<h3 id="signaller-unlock-targetid-opts-">signaller#unlock(targetId, opts?)</h3>
<h3 id="signaller-loadprimus-signalhost-callback-">signaller.loadPrimus(signalhost, callback)</h3>
<h2 id="signaller-process-handling">signaller process handling</h2>
<p>When a signaller&#39;s underling messenger emits a <code>data</code> event this is
delegated to a simple message parser, which applies the following simple
logic:</p>
<ul>
<li><p>Is the message a <code>/to</code> message. If so, see if the message is for this
signaller (checking the target id - 2nd arg).  If so pass the
remainder of the message onto the standard processing chain.  If not,
discard the message.</p>
</li>
<li><p>Is the message a command message (prefixed with a forward slash). If so,
look for an appropriate message handler and pass the message payload on
to it.</p>
</li>
<li><p>Finally, does the message match any patterns that we are listening for?
If so, then pass the entire message contents onto the registered handler.</p>
</li>
</ul>
<h2 id="signaller-message-handlers">signaller message handlers</h2>
<h3 id="announce">announce</h3>
<pre><code>/announce|{&quot;id&quot;: &quot;...&quot;, ... }</code></pre>
<p>When an announce message is received by the signaller, the attached
object data is decoded and the signaller emits an <code>announce</code> message.</p>
<h4 id="events-triggered-in-response-to-announce-">Events Triggered in response to <code>/announce</code></h4>
<p>There are two different types of <code>peer:</code> events that can be triggered
in on peer B to calling the <code>announce</code> method on peer A.</p>
<ul>
<li><p><code>peer:announce</code></p>
<p>The <code>peer:announce</code> event is triggered when a new peer has been
discovered.  The data for the new peer (as an JS object) is provided
as the first argument of the event handler.</p>
</li>
<li><p><code>peer:update</code></p>
<p>If a peer &quot;reannounces&quot; then a <code>peer:update</code> event will be triggered
rather than a <code>peer:announce</code> event.</p>
</li>
</ul>
<h3 id="leave">leave</h3>
<pre><code>/leave|{&quot;id&quot;:&quot;...&quot;}</code></pre>
<p>When a leave message is received from a peer, we check to see if that is
a peer that we are managing state information for and if we are then the
peer state is removed.</p>
<h4 id="events-triggered-in-response-to-leave-messages">Events triggered in response to <code>/leave</code> messages</h4>
<p>The following event(s) are triggered when a <code>/leave</code> action is received
from a peer signaller:</p>
<ul>
<li><p><code>peer:leave</code></p>
<p>The <code>peer:leave</code> event is emitted once a <code>/leave</code> message is captured
from a peer.  Prior to the event being dispatched, the internal peers
data in the signaller is removed but can be accessed in 2nd argument
of the event handler.</p>
</li>
</ul>
<h3 id="lock">lock</h3>
<pre><code>/lock</code></pre>
<p>A <code>/lock</code> request can only be sent within the context of a <code>/to</code> message
and thus must contain source data to be processed correctly.  The <code>/lock</code>
message is used to coordinate betwen two remote peers in the case that
both peers which to commence renegotiation at the same time.</p>
<p>In the case that two peers attempt to renegotiate with each other at the
same time, then the peer that has been identified as party <code>a</code> in the peer
relationship will take on the role of the initiator in the negotiation and
party <code>b</code> will respond to the offer sdp.</p>
<h3 id="unlock">unlock</h3>
<pre><code>/unlock|label</code></pre>
<p>Clear a remote lock</p>
<h2 id="license-s-">License(s)</h2>
<h3 id="apache-2-0">Apache 2.0</h3>
<p>Copyright 2013 National ICT Australia Limited (NICTA)</p>
<p>   Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at</p>
<pre><code> http://www.apache.org/licenses/LICENSE-2.0</code></pre>
<p>   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.</p>
</div>

<footer>
  <p>
    <a href="http://nicta.com.au">
      <img src="images/nicta-logo.gif" alt="NICTA logo" />
    </a>© NICTA 2013
  </p>
  <p class="license">Project source code is licensed under the <a href="https://github.com/rtc-io/rtc/blob/master/LICENSE">Apache 2.0</a>.</p>
  <a class="closing" href="#top"></a>
</footer>
</body>
<script src="js/app.js"></script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-26567546-2', 'rtc.io');
  ga('send', 'pageview');

</script>
</html>

